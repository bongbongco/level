정리 중...

# 1. HTTP/HTTP 2.0  
## 1.1. HTTP  
 Huyper Text Transfer Protocol의 약자로 WWW(World Wide Web)에서 하이퍼텍스트(hypertext) 문자를 교환하기 위하여 사용되는 통신규약.

### 1.1.1. Status code : HTTP 통신 중 요청의 상태 정보 제공
	1. 1xx - Informational - 정보교환
	2. 2xx - Success - 성공
		* 200 - OK	- 요청이 성공적으로 전송됨
	3. 3xx - Redirection - 방향 지정
		* 301 - Moved Permanently - 요청 페이지의 영구적인 위치 변화
		* 302 - Found	- 요청 페이지이 일시적인 위치 변화
	4. 4xx - Client Error - 클라이언트 오류
		* 404 - Not Found - 요청받은 자원을 서버에서 찾을 수 없을때 나타나는 상태 
		* 405 - Method Not Allowed - 서버에서 사용자가 요청한 주소의 메소드를 지원하지 않을때 나타남
	5. 5xx - server Error - 서버 오류

### 1.1.2. Request Method : 
	1. OPTIONS: 요청한 URL에 어떠한 메소드 요청이 가능한지 묻는다.
	2. GET: 다른 작업없이 데이터의 검색에 이용.
	3. HEAD: 데이터의 검색에 이용하나 GET과는 다르게 응답 HEADER만 받는다.
	4. POST: URL에 새로운 데이터를 보낼때 사용.
	5. PUT: URL에 저장될 정보를 보낸다.
	6. DELETE: URL의 리소스를 삭제한다.
	7. TRACE: 보낸 메세지를 다시 돌려받는다.
	8. CONNECT: 프록시에서 사용되는 예약 메소드.
		
## 1.2. HTTP 2.0
 Latency(지연 시간)를 줄여 웹의 속도를 개선하기 위해 등장. 효율적인 페이지 로딩을 위해 URL의 이미지, 스크립트등의 자원을 압축해 페이지 렌더링을 위한 요청횟수를 감소시켰다. 뿐만 아니라 server가 push가 가능해 웹페이지의 렌더링이 필요하단 사실을 알게되면 추가 요청없이 서버가 리소스를 제공한다. 그 외에도 성능 개선을 위한 요청 다중화, 헤더 압축, HOL Blocking해결을 위한 요청 우선순위 결정등이 있다.
 
	1. 특징
		* HTTP Header 데이터 압축
		* Server Push(서버에서 부터 시작되는 전송)
		* HTTP 1에서 존재하던 head-of-line blocking 문제 개선
		* 싱글 TCP connection내에서 병렬 페이지 로딩 구현
		* 2.0은 기존 버전인 1.1과의 높은 호환성(method, status codes 등)은 보장하고 클라이언트 서버 간 전송 및 프레임
		의 개선에 초점을 맞췄다.
		※ head-of-line blocking: 동일한 송신 포트 자원에 대한 처리량 경쟁으로 인해 처리량 지연 및 프레임 손실 발생 
		유발. 작업대기 중인 2개의 패킷이 존재할 경우 첫번째 패킷이 대기중이면 그 뒤 패킷들은 무조건 대기할때 발생.
		
	2. HTTP 2.0과 SPDY
		* SPDY : Google이 ‘speedy’라는 단어를 기반으로 제안한 새로운 프로토콜이다. HTTP의 단점들을 보완하여, 인터넷 
		환경을 보다 효율적으로 이용하기 위한 프로토콜이다. HTTP/2.0에서는 스펙에 SPDY를 반영할 예정이다.
		* 특징
			* TLS 위에서 동작한다. https에서만 적용가능
			* HTTP 헤더를 압축한다. 요청마다 반복되는 내용을 압축해 성능 향상 효과가 나타남
			* 바이너리로 프레임을 구성한다. 파싱 속도가 향상되고 오류확률은 낮아진다.
			* 다중 연결을 지원한다.	다수의 요청, 응답 을 동시에 처리 할 수 있어 속도 향상
			* 인터리빙을 허용한다. 우선순위가 높은 데이터가 더 빨리 전송 될 수있다.
			* 서버 푸시가 가능하다.
		
## 3. 결론
 HTTP 1.1 이 사용하는 전송방식(RFC7230)에는 몇가지 문제점이 존재했다. HTTP/1.0은 TCP connection에서 한번에 하나의 요청 만이 가능했고 HTTP/1.1에서는 그보다 발전하여 request pipelining을 사용했지만 여전히 HOL Blocking 문제가 존재했다. HTTP/2.0은 오랫동안 변화하지 않았던 HTTP를 현 웹 환경에 맞게 발전시켜 속도의 향상을 도모 한다는데 크 의의가 있다.
 
# 2. HTTPS

HTTP에 인증과 안전성을 더해서 안전한 통신을 지원하는 통신 규약(HTTP는 도청, 위장, 변조의 위험이 존재).
새로운 프로토콜이 아니라, HTTP 프로토콜의 소켓을 SSL이나 TLS로 대체하여 TCP로 직접 통신하지 않고 SSL과 통신하게 하여 암호화와 인증서를 이용할 수 있게 한다.

※ SSL : HTTP와 독립된 프로토콜로 어플리케이션 계층에서 동작하는 다른 프로토콜에도 적용이 가능하다.

## 하이브리드 암호 시스템?
HTTPS는 공통키 암호와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템입니다.
두가지 방식을 조합해서 장점을 살립니다.
키를 교환하는 곳에서는 공개키 암호를 사용하고 그 후의 통신에서 메시지를 교환하는 곳에서는 공통키 암호를 사용합니다.

## 공통키 암호

상호간에 키를 교환하는 암호화 방식을 공개키 암호화 방식이라고 합니다.
SSL에서는 공개키 암호화 방식을 채용하고 있습니다.
암호화, 복호화에 하나의 키를 같이 사용하는 방식입니다.

하지만 키를 누군가 손에 넣으면 누구라도 암호를 해독할 수 있는 문제가 있습니다.

## 공개키 암호

공개키 암호는 공통키 암호의 문제를 해결하기 위해 등장한 방식입니다.
공개키 암호에서는 서로 다른 두 개의 키 페어(쌍)를 사용합니다.
비밀키(private key)와 공개키(public key)가 그것입니다.
비밀키는 알려지면 안되는 키이며, 공개키는 누구에게나 알려져도 괜찮은 키입니다.

1. 암호를 보내는 측(클라이언트)이 상대의 공개키를 사용해 암호화를 합니다.
2. 암호화된 정보를 받아들인 상대(서버)는 자신의 비밀키를 사용해 복호화를 실시합니다.
이 방식은 암호를 푸는 비밀키를 통신으로 보낼 필요가 없으며 도청에 의해서 키를 빼앗길 걱정이 없습니다.

하지만 공개키가 진짜인지 아닌지를 서버에서 증명할 수가 없습니다.
이 문제를 해결하는 데는 인증기관(CA : Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있습니다.
인증 기관이란 클라이언트와 서버 모두 신뢰하는 제 3자 기관입니다.
공개키를 인증 기관에 제출하면 인증 기관은 제출된 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만듭니다.
그리고 공개키 인증서에 서명이 끝난 공개키를 담습니다.

이런 인증 기관의 공개키는 안전하게 클라이언트에 전달되어야 합니다.
하지만 어떤 방법을 사용하더라도 100% 안전이 보장되지 않기 때문에 많은 브라우저가 인증기관의 공개키를 사전에 내장한 상태로 제품을 내놓고 있습니다.

# 3. TCP / UDP

## 3.1. TCP
		(1) 정의 : 연결형 서비스를 위해 호스트 간 신뢰성 있는 데이터 전달과 흐름제어 및 혼잡제어 등을 
		제공하는 전송계층 프로토콜로 인터넷 환경에서 기본으로 사용된다. 
		
		(2) 특징
			- 가상 회선 연결 방식, 연결형 서비스를 제공
			- 높은 신뢰성(Sequence Number, Ack Number를 통한 신뢰성 보장)
			- 연결의 설정(3-way handshaking)과 해제(4-way handshaking)
			- 데이터 흐름 제어
			(수신자 버퍼 오버플로우 방지) 및 혼잡 제어(네트워크 내 패킷 수가 과도하게 증가하는 현상 방지)
			- 전이중(Full-Duplex), 점대점(Point to Point) 서비스
		
		(3) 소켓 통신 과정
			- 서버 : 소켓을 생성, 주소 할당, 연결 요청 기다림, 요청에 대한 응답
			- 클라이언트 : 소켓을 생성, 주소 할당, 연결 요청		
			
## 3.2. UDP
		(1) 정의 : 비연결형 서비스를 지원하는 전송계층 프로토콜로 정보를 보낸다는 신호나 받는다는 
		신호 절차를 거치지 않고, 일방적으로 데이터를 전달. 

		(2) 특징
			- 비연결형(port만 확인하여 소켓을 식별하고 송수신)
			- 패킷 오버헤드가 적어 네트워크 부하 감소
			- 비신뢰성
			- 오류검출(헤더에 오류 검출 필드를 포함하여 무결성 검사)
			- TCP의 handshaking 같은 연결 설정이 없다
			- DNS, NFS, SNMP, RIP 등 사용

		(3) 소켓통신과정
			- 서버 : 소켓을 생성, 주소 할당, 데이터를 송수신
			- 클라이언트 : 소켓 생성 후 데이터 수신

			UDP는 TCP와 달리 데이터의 수신에 대한 책임을 지지 않는다. 이는 송신자는 정보를 보냈지만, 
			정보가 수신자에게 제때에 도착했는지 또는 정보 내용이 서로 뒤바뀌었는지에 관해서 송신자는 
			상관할 필요가 없다. TCP보다 안정성 면에서는 떨어지지만, 속도는 훨씬 빠르다.
	
# 4. 쿠키/세션

	1. 쿠키/세션이 필요한 이유
		- HTTP 프로토콜은 연결 지향적인 통신이 아니므로 페이지 이동 시 마다 새로운 접속이 이루어지며 이전 
		페이지와 현재 페이지 간의 관계가 지속되지 않는다. 이러한 문제를 해결하기 위해서 쿠키와 세션을 사용한다.
	2. 쿠키
		- Client PC에 저장되어 다른 사용자에 의한 임의 변경 위험이 있다.
		- 생성 이후 서버로 전송되는 요청에는 쿠키 정보가 같이 포함되어 전송
		- 이름, 값, 유효기간, 도메인, 경로 등으로 구성
	3. 세션
		- Session에 관련된 데이터는 Server에 저장된다.
		- 웹 브라우저의 캐시에 저장되어 브라우저가 닫히거나 서버에서 삭제 시 사라진다.
		- Cookie에 비해 보안성이 좋다.
		- 저장 데이터에 제한 없음
		
		
# 5. 소켓서버/웹서버

## 5.1. 소켓서버
### 5.1.1. 서버와 클라이언트의 역할
* 서버: 클라이언트의 요청을 처리하고 그 결과를 클라이언트에게 알려주는 역할
* 클라이언트 : 서버에 작업을 요청하고 그결과를 받아서 보여주는 역할

### 5.1.2. TCP/IP
* 프로토콜 : 둘 이상의 통신 개체 사이에 교환되는 메시지의 형태, 의미, 전송 순서와 메시지 송수신 및 기타 사전에 수행할 동작을 정의한 규약
프로토콜은 두 개 이상의 호스트 사이에서 데이터를 주고 받는 약속으로 TCP/IP도 프로토콜의 한 종류이다. 

#### OSI 7Layer / TCP 4Layer

### 5.1.3. IP
IP는 인터넷 상의 고유 주소이다. IP는 A, B, C, D, E 클래스로 구성되는 데, 각 클래스 별 범위는 다음과 같다.

* A 클래스  | 0.0.0.0 - 127.255.255.255
* B 클래스  | 128.0.0.0 - 191.255.255.255
* C 클래스  | 192.0.0.0 - 233.255.255.255
* D 클래스  | 224.0.0.0 - 239.255.255.255
* E 클래스  | 240.0.0.0 - 255.255.255.255

E 클래스는 나중을 위해 예약되어 있는 클래스, D 클래스는 멀티캐스트를 위한 클래스이다.

### 5.1.4. 도메인 주소
여러 IP 주소를 사람이 외워서 사용하기에는 불편하기 때문에 사람이 사용하기 쉬운 도메인 주소를 정의하고 DNS 서비스를 이용하여 IP주소에 이를 매칭하여 사용한다.

### 5.1.5. PORT
하나의 컴퓨터에 실행 중인 여러 네트워크 프로그램을 구분하기 위해 부여된 번호이다. 예를 들자면 집을 호스트로 IP를 우편물 주소로 받는 이를 Port로 생각하면 이해하기 쉽다. 1 ~ 1024 는 미리 정의되어 사용되고 있으므로 새로운 서버를 만든다면 이 포트 번호를 피해서 만드는 것이 좋다.

### 5.1.6. Loopback
클라이언트와 서버가 같은 호스트에서 TCP/IP를 이용하여 서로 통신할 수 있도록  127.0.0.1 - 127.255.255.255 까지가 루프백 주소로써 localhost라는 이름으로도 할당하고 있다. 브로드캐스트나 멀티캐스트주소로 보내어진 것은 루프백에 복사된 다음 밖으로 나가게 된다.

### 5.1.7. MTU
Maximum Transmission Unit - 최대 전송단위로 대부분의 네트워크는 패킷의 상한선이 정해져 있으며 그 보다 클 경우, 분할하여 보낸다. 이것을 단편화(Fragmentation)라 하고 단편화된 패킷은 수신 시 합쳐지게 된다.
※ Path MTU : 두 호스트 사이에 패킷을 전송하는 링크상의 최소 MTU 크기가 Path MTU라 합니다. 만약에 A 와 D가 통신을 한다고 하면 A와 D사이에는 B, C 라는 네트워크가 있다고 해봅시다. A - B - C - D

A의 MTU가 100 B 200 C 70 D 80이라는 MTU를 가지고 있다면 A와 D의 Path MTU는 70이 되는 것입니다.

### 5.1.8. TTL
Time-to-live 의 약자로 패킷이 통과할 수 있는 라우터의 수를 제한하기 위해 사용된다. 하나의 라우터를 거칠 때 TTL 값은 1 줄어들고 0이 되면 패킷은 삭제된다. 
※ 게이트웨이 : 서로 다른 네트워크를 연결하는 역할

### 5.1.9. TCP 연결 / 연결종료
#### TCP 연결 - 3Way Handshaking
1. 서버 : 클라이언트의 요청을 받을 준비
2. 클라이언트 : 서버에 접속 요청 (SYN)
3. 서버 : 클라이언트에게 클라이언트의 SYN 도착을 알림 (SYN, ACK)
3. 클라이언트 : 서버에게 서버의 SYN 도착을 알림 (ACK)

#### TCP 연결 종료
1. 클라이언트 : 연결 종료를 서버에게 알림 (FIN)
2. 서버 : 클라이언트에게 클라이언트의 FIN이 도착했음을 알림 (FIN/ACK)
3. 클라이언트 : 서버에게 서버의 FIN이 도착했음을 알림 (ACK)

### 5.1.10. 소켓 API


### 5.1.11. I/O 모델
#### Blocking I/O
소켓을 열면 기본적으로 Blocking I/O mode이다. 서버가 클라이언트로부터 데이터를 받기 위해 recv() 함수를 호출하고 프로세스는 클라이언트로 데이터가 올 때까지 멈춰있는 데 이를 Blocking이라 한다. 간단하고 수행하는 기능이 별로 없는 서버는 Blocking으로 만드는 것이 가능하지만 많은 사용자들이 요청하는 다양한 기능을 처리하는 서버로는 적합하지 않다. 왜냐하면 한 클라이언트에게 데이터를 받기 위해 recv()에서 서버가 멈춰있는다면 서비스 지연 및 서버 활용도를 저해하기 때문이다. 

#### Non-Blocking I/O
Non-Blocking은 요청한 I/O를 처리할 수 있다면 처리하고 처리하지 못한하면 함수를 리턴하여 다른 작업을 할 수 있게 한다. 여기서 I/O를 처리할 수 없어 리턴될 때 다른 오류 코드를 리턴하여 I/O가 이뤄졌는 지 이뤄지지 않았는 지를 확인하여 동작하는 모드가 Non-Blocking mode이다. 
요청한 I/O를 할 수 없다면 클라이언트로부터 데이터를 받을 때까지 확인하는 작업이 필요해진다. 반복적으로 이렇게 데이터를 다 받았는지 확인하는 것을 Polling이라 한다. 이는 CPU 낭비를 초래하므로 클라이언트가 데이터를 보내왔을 때 서버에 데이터를 보내왔다는 것을 알려 준다면, Polling을 하는 것보다 더 좋은 성능을 보여 줄 수 있을 것이다.

#### I/O Multiplexing
입출력 다중화. select() 함수나 poll() 함수를 이용하여 구현한다. 이런 함수들을 이용하여 I/O를 호출하면 실제로는 시스템에서 Blocking되지만 어플리케이션에서는 Blocking 되어 있지 않는다.여러 개의 소켓을 설정하여 그 소켓에 send, recv, error 등을 설정할 수 있다. 그러면 시스템에서 설정된 사항에 맞는 상황 발생 시에 어플리케이션에게 그 사항을 알려준다. 그러면 어플리케이션이 거기에 알맞은 처리를 해준다. 여기서 문제점은 한번에 select() 함수로 설정해 줄 수 있는 소켓 개수에 제한이 있다는 것이다.

#### Signal Driven I/O
인터럽트와 유사한 방법으로 어떤 I/O를 요청하고 그것이 준비되면 어플리케이션에게 신호를 보내 준비되었다는 것을 알려준다. 만약 이러한 방법을 사용한다면 클라이언트에게서 데이터가 들어 왔다면 어플리케이션에게 지정한 신호가 어플리케이션으로 온다는 것이다. 어플리케이션은 신호에 맞게 처리를 해주면 된다. 하지만 이 방법에는 문제가 있는 데 신호가 중복되어 들어온다면 뒤에 온 신호는 무시된다. 그리고 이 방법은 TCP 에는 적당하지 않다고 하는데 TCP 에서는 신호를 설정해두면 수많은 신호들이 어플리케이션에게 온다고 한다. 그리고 신호가 발생되어도 어떤 일이 있었는지 알 수 없다고 한다. 그래서 주로 UDP에서 사용된다.

#### Asynchronaus I/O
Signal Driven I/O 에서는 I/O작업이 시작되는 순간에 신호를 보내어 알려준다. 비동기에서는 I/O작업이 완료되었을 때 이 사실을 알려준다.

많은 방법들이 있는데, Blocking 에서는 block 당하는 것을 해결하려고 non-blocking 이 나오고 non-blocking 의 폴링(polling)을 해결하려는 여러 가지 방법들이 나온 것 같습니다.

유닉스에서는 주로 I/O Multiplexing 을 많이 사용한다고 합니다. 그러나 실제 성능을 테스트해보면 non-blocking 이 가장 좋은 성능을 낸다고 합니다. 그런데 non-blocking 은 적성이 힘들고, 유지보수가 힘들다고 합니다. 그래서 I/O Multiplexing 을 사용하라고 권장하는 것 같습니다.

요즘에는 kqueue 가 BSD 계열 유닉스에서는 그것이 가장 좋은 성능을 낸다고 하고 윈도우에는 IOCP(I/O complete port)가 좋은 성능을 낸다고 합니다. 그러면 이런 좋은 성능을 내는 것만 사용하면 되지 않을까요? 그런 건 아닌 것 같습니다. 그 서버의 역할에 맞는 I/O 모델을 사용하는 것이 가장 효율적일 것입니다. Blocking 으로 충분히 감당할 수 있는 서버인데 무리해서 다른 모델을 도입하는 것은 개발 속도와 유지보수 면에서 불리한 면이 있을 수 있습니다. 그리고 서버의 여러 가지 설계, 그런 부분에서 해당 서버에 잘 맞는 I/O 모델을 선택해서 쓰면 되겠지요.

#### POSIX Thread
##### Thread vs Process
각 클라이언트를 다루기 위해 새로운 프로세스를 하나 만드는 것은 비용이 많이든다.

* 프로세스가 하나 생성될 때마다 운영체제는 메모리, 스택, 파일/소켓 식별자들 및 기타를 포함한 부모 프로세스의 전체 상태를 복사
* Thread들은 같은 프로세스 내의 멀티태스킹을 허용함으로써 이러한 비용을 감소. 새로 생성된 Thread는 부모와 같은 주소공간(코드 및 데이터)을 공유하고, 부모의 상태를 복제할 필요성 배제
* 프로세스 복제이후 부모와 자식간에 정보를 주고받기 위해 프로세스간 통신(IPC) 필요 (자식으로부터 부모로 정보를 되돌리는 것은 더욱 많은 작업을 요구)
* 프로세스 중의 모든 Thread가 공유하는 것
  * 프로세스 지시 사항
  * 대부분의 데이터
  * 공개된 파일들(Ex 지정 번호들)
  * 신호 처리기와 신호 배치들
  * 사용자와 그룹 ID
* 각 Thread 자신만이 갖는 것
  * Thread ID
  * 프로그램 계수기와 스택 지시자를 포함한 레지스터의 조합
  * (지역변수와 반환 주소를 위한) stack
  * errno
  * 신호 선별
  * 우선순위
  
[1](http://www.gpgstudy.com/gpgiki/%EC%86%8C%EC%BC%93_%EA%B0%95%EC%A2%8C)  

## 5.2. 웹서버
### Web Server vs Was Server
* Web Server : HTML 문서 같은 정적 컨텐츠를 처리하는 서버(HTTP 프로토콜을 통해 읽을 수 있는 문서) 웹 브라우저에게 정적인 HTML이나 jpeg, gif 같은 이미지를 HTTP 프로토콜을 통해 제공한다. 최근에는 내부 어플리케이션을 동작시킬 수 있는 컨테이너를 내장하고 있다.
* Was Server : 서버 사이드 언어를 읽고 처리하여 동적 컨텐츠, 웹 응용 프로그램 서비스를 처리하는 서버. 서버 단에서 어플리케이션을 동작할 수 있도록 지원한다. 일반적으로 컨테이너라는 용어로 쓰인다. 

처리하는 기능은 나누어져있지만 요새 WAS 서버에는 WEB서버 기능을 포함하고 있다고 한다. 
 
WAS에 대해서 좀더 살펴보자면, J2EE 스펙을 구현한 서버로 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산환경에서 사용되는 미들웨어이다. 웹서버 + 웹 컨테이너로 웹상에서 사용하는 컴포넌트를 올려놓고 사용하게 되는 서버이다.
Web Logic, Jeus, Tomcat, JBoss 등이 있다. Tomcat 같은 경우 WAS가 아니라는 사람들도 있는데 이는 Tomcat에는 EJB 컨테이너로의 기능이 없기 때문이다.
 
WAS가 컨테이너도 포함될 수 있다고 하는데 이 컨테이너 Containner 무엇이냐면 JSP와 Servlet을 실행시킬 수 있는 SW를 웹 컨테이너라고 한다.

JSP를 배울 때 대체적으로 Apache와 Tomcat을 사용한다. Apache는 웹서버를 담당하고 Tomcat은 WAS 다. ASP를 구동하기 위해서는 IIS를 사용한다. ASP의 환경이 MS계열 서비스라면 WAS의 기능을 담당하는 부분이 있어 별도의 WAS가 필요하지않다.
 
그렇다면 ASP처럼 하나를 쓰지 않고 WAS와 웹서버가 동시에 왜 필요할까.
우리가 만드는 웹페이지는 정적 컨텐츠만 있는 것도 아니고 동적 컨텐츠도 함께 노출되게 된다.
WAS가 정적 데이터를 처리로 인해 동적 컨텐츠의 처리가 지연이 될 것이고 이로 인한 페이지 노출시간이 늘어나게 된다.
WAS는 동적 처리에 최적화 되어 있는 서비스이기 때문에 처리 속도를 위해, 정적처리는 웹서버에서 처리를 하고, 동적 컨텐츠는 WAS에서 처리하게 된다.
간단히 말하면 분산처리를 위한 것이다. 
 
사용자가 클라이언트(브라우저)에 요청을 하게 되면 이를 웹서버에서 반응하여 WAS의 처리를 거쳐 웹페이지로 다시 웹서버에서 클라이언트(브라우저)에 응답 메세지를 주는 것이다.
 
한마디로 대답하면 WEB 서버가 처리할 수 있는 형태로 가공하여 제공해줄수 있는 웹 어플리케이션 정도가 될까.
WAS를 사용하는 이유는 WEB서버에서는 웹 문서만 처리하도록 기능을 분배하여 서버의 부담을 줄이기 위한 것이라 할 수 있다.  
[1](https://github.com/lesstif/web-service-hardening/blob/master/web-server.md)  
[2](http://round1tko.tistory.com/64)  
	
# 6. IOCP

 IOCP는 Input/Output Completion Port의 약자로 입력과 출력의 완료를 담당할 포트를 지정해서 처리하겠다는 의미이다. 입력과 출력의 완료시점에서의 통지는 overlapped(중첩 입출력)에서 처리가 되므로, 이 기술은 윈도의 중첩 입출력 기술을 확장시킨 것으로 볼 수 있다.
포트는 작업 혹은 서비스를 전담하기 위해서 만들어지는 객체다. 소켓의 포트가 특정 서비스로 데이터 입출력을 전달하기 위한 객체임을 상기하면 이해가 쉬울 것이다. 이러한 포트의 특징을 이해하면, 입출력 완료 시점에서 이에 대한 통지를 전담할 포트를 만들어서 데이터를 처리하는 방식도 충분히 생각해 볼 수 있을 것이다.  

입출력 장치(소켓)로 부터 입출력이 완료되면 입출력 완료 대기열에 쌓인다. 그 후 스레드를 깨우고 스레드가 대기열에 있는 완료보고를 읽어 데이터를 처리한다.

* 장점 : 클라이언트가 연결 할 때 마다 스레드를 만드는 멀티 스레드 방식과 달리, 미리 스레드를 만들어서 입출력 완료 보고를 기다리도록 할 수 있다는 점이다. 이렇게 적당한 개수의 워커 스레드를 만들어 두면, 운영체제가 쉬고 있는 워커 스레드를 깨울 수 있다. 스레드 혹은 프로세스 풀과 유사하지만 차이가 있다. 스레드 풀 방식은 쉬고 있는 스레드에 작업을 할당하기 어렵다. 하지만 IOCP는 운영체제가 알아서 스레드를 선택해서 깨운다.

## IOCP 프로그래밍
### IOCP 프로그램 처리 과정
1. 워커 스레드 생성 : 적당한 개수의 워커 스레드 생성 (워커 스레드는 완료보고 통지를 기다림)
2. 소켓 생성
3. accept() 함수 호출
4. 연결 시 소켓을 CP(Completion Port)에 할당
5. WSARecv(:4100)함수를 호출. (소켓은 비동기, 중첩 소켓이다)

## 워커 스레드
워커 스레드는 GetQueuedCompletionStatus(:4200)로 완료 통보를 기다린다. 이 함수는 OVERLAPPED(:12) 구조체를 되돌려 주는데, 이 구조체에서 정보를 토대로 데이터를 처리하면 된다.

## 소켓 CP에 할당하기
파일 관리 함수인 CreateIoCompletionPort(:4200)함수로 소켓을 CP에 할당할 수 있다. 이제 해당 소켓에 입출력 완료가 이루어지면 입출력 완료 대기열에 완료보고가 쌓이고, 워커 스레드들 중 하나가 깨어나서 작업을 처리한다.

CreateCompletionPort 함수는 HANDLE을 등록시키는 함수이므로, 소켓의 경우 HANDLE로 형 변환해서 사용한다.

## 비동기 입출력 수행
WSA 계열 함수를 이용해서 (중첩)비동기 입출력을 수행한다.

### Overlapped I/O 모델
소켓은 기본적으로 봉쇄/동기로 만들어진다. 이 모델은 데이터 입출력 부분에서 봉쇄(blocked)된다는 문제점을 가진다.
이 모델로는 하나의 쓰레드에서 두 개 이상의 소켓을 다루기가 힘들다. 이 모델을 바꾸지 않고 두개 이상의 소켓을 처리하려면 "멀티 쓰레드" 기술을 함께 사용하는 수 밖에 없다.
윈도 운영체제(:12)는 멀티 태스킹을 지원한다. 이는 입출력:::모델(:12)과는 상관없이, 커널은 여러 소켓으로 부터의 입력을 처리한다는 의미다. 이 기능을 봉쇄/동기 입출력 모델의 한계로 쓰지 못하는 것일 뿐이다.
이 문제는 입출력 모델을 "비동기 / 봉쇄" 혹은 "비동기 / 비봉쇄"을 쓰는 것으로 해결할 수 있다. 비동기 봉쇄 모델을 사용하는 기술이 select(:2)함수를 이용한 입출력:::다중화(:12)이다. Overlapped I/O 모델은 "비동기 / 비봉쇄 모델"의 응용 모델이다. Overlapped에는 non-blocking이 포함되어 있다. 즉 Overlapped 는 non-block + (비동기적) 완료 통보 라고 보면 된다.

앞서 언급했듯이 커널은 여러 개의 소켓의 데이터를 동시에 다룰 수 있다 보면 시간을 축으로 데이터가 중첩이 되는 구간이 생길 수도 있을 것이다. 이제 데이터의 입력이 완료되면, 해당 소켓에서 이벤트를 통지한다. 이벤트를 받은 프로세스는 이벤트 객체를 이용해서 데이터를 처리하거나 혹은 Completion Routine를 이용해서 데이터를 처리할 수 있다. 중첩해서 들어올 수 있는 데이터의 처리를 커널에 맡기게 되므로 유저 모드에서 블럭되는 일 없이 여러 개의 소켓을 처리할 수 있다.

Overlapped I/O의 중첩을 허용하는 이런 특징 때문에, "중첩 입출력 모델"이라고 부르기도 한다. 생소한 기술 같지만, 원리에 있어서는 리눅스(:12)의 입출력:::다중화(:12)나 리얼:::타임:::시그널(:12)과 큰 차이가 없음을 알 수 있다. 다음은 비 동기 / 비 봉쇄 입출력모델을 따르는 프로그램의 흐름을 보여준다.
1. 읽기 함수를 호출하면, 커널은 데이터를 읽기 위한 초기화 작업을 하고 데이터를 기다린다. 읽기 함수는 바로 반환한다.
2. 이제 프로그램은 다른 작업을 진행한다.
3. 데이터가 입력되면, 이벤트가 발생한다.
4. 프로그램은 콜백함수 혹은 이벤트 객체를 만들어서 데이터를 읽어서 처리한다.

하지만 리눅스의 입출력 다중화나 리얼 타임 시그널등 비동기 입출력 기술과 차이점이 있다. 이들 리눅스 모델은 데이터 입력이 완료된 시점에서 데이터를 읽는 방식이 아니다. 소켓으로 데이터가 입력되는 시점에서 커널 데이터를 유저 데이터로 복사한다. 이말은 커널로 부터 데이터의 복사가 끝날 때까지 몇 번이나 입출력 함수를 호출 할 수도 있음을 의미한다. 여러 번 유저 모드와 커널 모드간의 변환이 있으므로 성능이 감소할 수 밖에 없다.  
윈도의 Overlapped I/O모델은 데이터 입출력이 완료된 시점에서 이벤트를 발생한다. 이로 인해 얻을 수 있는 이점은 다음과 같다.
1. 모드 변환이 발생하지 않는다. (여러 번의 데이터 복사가 발생하지 않는다.)
2. 데이터 입출력이 진행되는 동안에도 다른 일을 할 수 있다.

### Overlapped 소켓 프로그램
socket 함수로 만든 소켓은 기본적으로 중첩 특성을 가진다. 그러나 다른 BSD:::소켓(:12)입출력 함수들로는 중첩 소켓을 다루지 못한다. 그러므로 BSD:::소켓(:12) 입출력 함수대신 WSASend(:4100), WSARecv(:4100), WSASendTo(:4100), WSARecvFrom(:4100) 등의 함수를 이용해야 한다. WSASocket(:4100) 함수로 소켓을 만들 경우에는 WSA_FLAG_OVERLAPPED를 지정해줘야 한다.
중첩 소켓을 사용은 WSAsend(:4100) 함수의 lpOverlapped 매개 변수와 lpCompletionRoutine 매개 변수로 이루어진다.
1. lpOverlapped : WSAOVERLAPPED(:4300)구조체의 포인터를 넘긴다. 만약 NULL 이라면 중첩 소켓 특성을 사용하지 않는다.
2. lpCompletionRoutine : 입력이 완료 되었을 때 호출할 완료 루틴을 설정한다. 만약 NULL 이라면, 이벤트 객체 기반으로 처리한다.

#### 이벤트 객체 기반 처리
lpCompletionRoutine이 NULL일 경우, WSAOVERLAPPED 구조체의 이벤트 객체 핸들러로 입력을 처리한다. 이때 accept(:4100)함수를 어떻게 처리해야 할 것이낙 하는 문제가 있다. accept 함수는 중첩 소켓 특성을 이용하지 못한다. 또한 WSAAccept 함수도 중첩 소켓 특성을 이용하지 못한다. accept는 단 1 바이트만 들어와도 요청이 완료되므로, 굳이 중첩 특성을 이용할 필요가 없기 때문이다. acceptEx 함수가 있기는 하지만, 그다지 쓰고 싶지 않다.
다음 두 가지 방법 중 하나를 선택하면 될 것 같다.
1. 멀티 쓰레드(:12) 프로그래밍
accept는 메인 쓰레드에서 처리하고, 입출력은 워커 쓰레드에서 처리하도록 한다. 두 개의 쓰레드가 필요하다.
1. WSAEventSelect 모델을 이용해서 처리한다.
이벤트 객체 기반 처리 예제. 멀티 쓰레드를 이용해서 accept 처리를 분리 했다.
##### 예제

#### 콜백 함수 호출
##### 예제
[1](https://www.joinc.co.kr/w/Site/win_network_prog/doc/overlapped)


## 예제
[1](https://www.joinc.co.kr/w/Site/win_network_prog/doc/iocp)  
[2](http://ozt88.tistory.com/23)  
 
# 7. 하둡
대량의 자료를 처리할 수 있는 컴퓨터 클러스터에서 동작하는 분산 응용 프로그램을 지원하는 프리웨어 자바 소프트웨어 프레임워크이다.
## 개념
HADOOP (High-Availability Distributed Object-Oriented Platform)
* 정형, 비정형 대용량 데이터를 모아 분석, 통계, 예측하기 위한 도구

## 등장 배경
* 분석할 데이터가 기존 데이터에 비해 너무 방대해 이전 방법이나 도구로 수집, 저장, 검색, 분석, 시각화 등이 어려움(비정형 데이터 급증)
* 기존 데이터베이스 SW가 저장, 관리, 분석할 수 있는 범위를 초과하는 규모의 데이터 발생

### 빅데이터 특성 - 3V
* Volume (데이터량)
* Variety (다양성)
* Velocity (빠른 생성, 빠른 처리)

## 목적
여러 대의 컴퓨터를 병렬 연결, 상호 협력하여 컴퓨팅의 성능과 효율 향상

## 구성
### HDFS (Hadoop Distributed File System)
대규모 분산 파일 시스템 구축의 성능과 안정성을 보여줌

* 클러스터 환경에서 대용량 데이터를 분산해서 안정적으로 저장하는 프레임워크
* 큰 파일을 일정 크기의 덩어리로 쪼갬
* 덩어리를 복제하여 전체 클러스터에 분산 저장
* 일부 노드 장애는 서비스에 영향을 주지 않음
* 수백 GB ~ 수 TB 까지 지원
* Write Once Read Many 파일 시스템
  * 한번 작성되면 바뀔 필요없는 경우
  * Append 만 가능
* 병렬 처리 지원

### Map Reduce (분산 처리 프로그래밍)
HDFS에 저장된 대규모 분산 파일에 대한 로그 분석, 색인 구축, 검색에 탁월한 능력을 발휘

#### 기존 프로그래밍 방식
맵리듀스 이해를 위해 기존 프로그래밍 방식을 살펴보자.
	데이터를 가져온다. (fetch)
	가져온 데이터를 처리한다. (process)
	처리한 데이터를 저장한다. (save)

기존의 프로그래밍은 데이터를 가져와서 중앙에서 처리하고 다시 저장하는 구조이다. 따라서 데이터가 많을 경우 데이터를 가져오는 비용이 많이 든다. 이를 극복하기 위해 맵리듀스는 데이터를 가져오지 않고 데이터가 저장된 곳에서 치라할 수 있도록 만들었다. 맵리듀스는 크게 맵 단계와 리듀스 단계로 나뉜다. 맵 단계가 바로 데이터가 저장된 로컬에서 동작한다.

다음으로 파티셔너와 컴바이너를 살펴보자.
파티셔너는 맵 함수의 결과를 각 파티션으로 나누어 저장하는 역할을 한다.
파티션을 나누는 기준은 키이며, 기본적으로 키에 해쉬 함수를 적용해 처리한다.

컴바이너는 일반적으로 리듀서와 동일하게 사용되어 '로컬 리듀서'라고도 불리우는 데 로컬에서 리듀스 함수를 먼저 처리하여 네트워크로 전달하는 데이터 양을 줄이기 위해서 사용된다. 리듀스 함수를 컴바이너로 사용하기 위해서는 리듀스 함수의 입력과 출력의 타입이 같아야 한다. 그렇지 않을 경우, 별도의 컴바이너를 구현해서 사용한다.

#### 맵리듀스 구조
대용량 입력 파일을 분리(Split)한 후, 맵 함수를 적용한다.
그리고 리듀스 함수에 전달하기 위해 셔플링(Shuffling)이 일어나고 최종 결과를 생성한다.

하둡에서 최초 입력 파일은 먼저 스플릿(split)해서 HDFS에 저장한다.
대용량 파일을 한번에 처리할 수 없기 때문에, 적절한 크기로 잘라낸 후 맵리듀스로 처리하는 것이다.
하지만 스플릿의 크기가 너무 작을 경우, 분할 관리 및 맵 테스트 생성의 오버헤드가 있어 역효과가 날 수 있다.
보통 하둡에서 64MB 이상의 스플릿을 사용하도록 권장하고 있다.

셔플링은 맵 함수의 결과를 취합하기 위해 리듀스 함수로 데이터를 전달하는 역할을 한다.
그 전에 맵 함수의 결과에 대해 정렬과 병합이 일어난다. 그리고 각 서버에 나뉜 데이터들을 키를 중심으로 합쳐서 리듀스 함수에 전달한다. 이렇게 리듀스 함수로 데이터를 전달하는 것을 셔플링이라고 한다.

* 하둡 분산파일시스템에 저장된 분산 데이터를 클러스터로 연결된 컴퓨팅 노드들이 병렬로 데이터를 처리하는 프레임워크
* 함수형 프로그램에서 일반적으로 사용하는 Map과 Reduce라는 함수 기반으로 구성
* 복잡한 컴퓨팅을 Map/Reduce 두 가지로 단순화

## 시각화
* 정의 : Visualization은 숫자를 공간에 배치하여 보여줌으로써 그 패턴을 인지하게 만드는 것이다.
* 통계/분석의 가장 중요한 부분
  1. 데이터의 특성을 쉽게 파악
  2. 결과 보고서에 활용
* 근거 : 사람은 탁월한 패턴 인식 능력이 있음
* 데이터 페턴 파악의 도구, 분석을 돕는 역할

## 더 알아보기
### 주키퍼
하둡의 분산 상호 조정 서비스를 이용하여 분산환경에서 노드들간의 정보 공유, 락, 이벤트 등의 보조 기능을 제공한다. 분산 프로그램에서는 부분적 실패(Partial failure)라는 것이 발생할 수 있다. 예를 들어, 두 노드 사이의 메시지가 송신되고 네트워크가 끊어졌을 때, 송신자는 수신자가 메시지를 받았는지 알 수 없다. 즉, 연산이 실패했는지 조차도 모르는 상황이 바로 부분적 실패라고 한다. 주키퍼는 이러한 부분적 실패에서 안전하게 해준다. 하둡, HBase, Kafka 등에서 주키퍼를 사용하고 있다.

주키퍼는 고가용, 고성능을 위한 상호 조정 서비스로 znode라는 노드 계층적 트리를 유지한다. 이 znode는 데이터를 저장하는 것인 데, 큰 용량의 데이터를 저장하는 용도로 사용되지 않으면 znode에 저장할 수 있는 데이터 양은 1MB로 제한된다.
주키퍼는 대용량을 처리하도록 구성되어 있지 않기 때문에, 주키퍼를 사용해서 새로운 어플리케이션을 설계한다면 어플리케이션과 상조 조정 데이터를 분리해야 한다.

예를 들어, 웹 메일 서비스를 분산 환경으로 만든다면 어플리케이션 데이터는 메일박스의 컨텐츠라고 할 수 있다. 반면에 주키퍼와 같은 조정 데이터는 분산된 메일 서버에 각 메일 박스를 매핑하는 것이라 할 수 있다. 이렇게 데이터를 분리한다는 관점에서 보면, 주키퍼의 처리 용량이 왜 작게 설계 되어 있는지 이해할 수 있다.

#### 기본 연산
* create : znode 생성
* delete : znode 삭제
* exists : znode 존재 여부 확인 후 메타데이터 구함
* getACL, setACL : znode에 대한 ACL 정보를 가져오거나 설정함
* getChildren : znode 자식의 목록을 얻음
* sync : znode의 클라이언트 뷰와 주키퍼를 동기화 

Java와 C언어를 위한 바인딩 제공 및 Perl/Python/Rest 클라이언트를 위한 Contrib 바인딩 제공

주키퍼는 개념적으로 매우 간단하다. znode의 트리에 대한 모든 수정이 앙상블 노드에 복제되도록 보장한다. 만약 소수의 컴퓨터에 장애가 생기면 최소 한 개의 컴퓨터는 가장 최신 상태를 유지한다. 그리고 다른 남은 복제 노드가 이 최신 상태를 복제해갈 것이다.

### 피그
맵리듀스로 할 수 없는 대용량 데이터셋의 고차원적 처리를 지원하는 스크립트언어로 내부적으로는 연속된 맵리듀스 작업으로 변경하지만, 개발자는 데이터 자체에 집중할 수 있게 해준다. 또한 확장이 용이하게 설계되어 있어 로딩, 저장, 필터링, 그룹핑, 정렬, 조인 등 모든 부분이 사용자 정의 함수를 통해서 변경할 수 있다. 하지만 내부적으로 맵리듀스로 변호나해서 실행해야 하므로 맵리듀스로 작성된 프로그램만큼 좋은 성능을 내지 못한다.
피그 프로그램을 실행하는 방법은 세 가지가 존재한다.
* 스크립트(Script) : 피그 명령어가 포함된 스크립트 파일 실행
* 그런트(Grunt) : 대화형 쉘
* 내장형(Embeded) : Java에서 피그 프로그램 실행

피그는 데이터 흐름을 표현하기 위해 사용하는 피그 라틴이라는 언어와 피그 라틴 프로그램을 수행하는 실행환경으로 구성된다. 현재 단일 JVM 로컬 실행환경과 하둡 클러스터 상의 분산 실행환경 두 종류가 있다. 피그 라틴 편집 시 이클립스의 "PigPen" 플러그인을 사용하면 좋다.

### HBase
HDFS에 구현한 분산 컬럼 기반 데이터베이스로 대규모 데이터셋에 실시간으로 랜덤 액세스가 필요할 때 사용할 수 있는 하둡 응용프로그램이다.

HBase는 확장성을 위해서 단지 노드만 추가하면 선형적으로 확장이 가능하며, 관계형 데이터베이스가 아니고 SQL도 지원하지 않지만 기존 RDMS에서 부족한 기능을 대체할 수 있다.

일반적으로 하둡은 Row 레벨 업데이트. 빠른 응답을 요구하는 쿼리, 트랜젝션을 지원하지 않는다. 
반면 HBase를 사용하면 Row level update, rapid queries, row level transaction을 사용할 수 있다.

응용프로그램은 데이터를 테이블에 저장한다. 테이블은 로우와 칼럼으로 만들어져 있다. 테이블 셀은(로우와 컬럼의 교차지점) 버전 관리된다. 기본적으로 버전은 셀 생성 시점에서 HBase에 의해 자동 할당된 타임스탬프이며 셀의 내용은 원시 바이트 배열이다.

HBase는 컬럼 패밀리로 구성된 컬럼 기반으로 되어 있으며 Key-Value 저장 구조를 가지고 있다. 각각의 Row에 하나의 Single Key가 사용되기 때문에 해당 Row의 컬럼이나 컬럼 패밀리에 빠르게 읽고 쓸 수 있다. 그리고 timestamp를 활용해서 각 컬럼 값들의 버전관리가 가능해서 필요할 경우 과거 특정 시점으로 되돌아 갈 수 있다.

테이블은 HBase에 의해 리전으로 자동 수평분할된다. 각 리전은 테이블의 로우의 부분집합으로 구성된다. 리전은 첫 번째 로우와 마지막 로우, 추가로 무작위 생성된 리전 식별자에 의해 정의된다. HBase의 마스터노드가 하나 이상의 리전 서버를 조율하게 된다.

HDFS와 맵리듀스가 대량의 데이터 집합에 대한 배치 작업을 처리하기에 강력한 도구이지만, 개별 레코드를 효과적으로 읽거나 쓰는 방법을 제공하고 있지 않으므로 이러한 실시간 처리 기능을 위해 HBase를 활용하게 된다.

### Hive 
[1](http://blog.acronym.co.kr/329)  

# 8. jquery / bootstrap / ajax

## 8.1. javascript
자바스크립트는 ECMAScript 표준 명세를 따라 구현된 객체 기반 스크립트 프로그래밍 언어이다. HTML 태그 또는 엘리먼트라고 불리는 DOM(Document Object Model)과 BOM(Browser Object Model)을 조작하거나, SPA(Single Page Application)에서 서버와 Ajax 통신을 하는 용도로 주로 사용된다.
[1](https://github.com/nhnent/fe.javascript/wiki/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0)  
	
## 2. jquery
자바스크립트의 생산성을 향상시켜주는 자바스크립트 라이브러리
	
## 3. bootstrap
트위터에서 시작된 HTML5 기반의 오픈 소스 웹 디자인 프레임워크
		
## 4. ajax
Web에서 화면을 갱신하지 않고 Server로 부터 Data를 가져오는 방법
### 4.1. 동작원리
Ajax의 동작원리는 Browser에서 서버로 보낼 Data를 Ajax Engine을 통해 Server로 전송합니다. 이 때 Ajax Engine에서는 JavaScript를 통해 DOM을 사용하여 XMLHttpRequest(XHR) 객체로 Data를 전달합니다. 이 XHR을 이용해서 Server에서 비동기 방식으로 자료를 조회해 올 수 있습니다. Server에서 Data를 전달 할 때 화면전체의 HTML을 전달하지 않고 Text 또는 Xml형식으로 Browser에 전달합니다.
### 4.2. 사용방법
Ajax의 기본 Method를 이용해서 Server와 통신하려면 XMLHttpRequest를 직접 사용하기 때문에 상당히 복잡하다. 하지만 jQuery를 이용하면 간단히 구현할 수 있다.
	// jQuery를 이용한 Ajax 기본 사용방법입니다.
	$.ajax({
		// URL은 필수 요소이므로 반드시 구현해야 하는 Property입니다.
		url : '요청 URL 주소를 입력합니다.'
		// 다양한 속성들 중에서 필요한 Option을 선택해서 구현합니다.('[]'는 반복해서 사용할 수 있다는 의미입니다.)
		[, Options]
	});

#### 4.2.1. Ajax 통신에 필요한 Property

* url : 요청 전송 URL
* type : HTTP 요청 방식 (GET/POST)
* timeout : 요청 제한 시간
* success : 요청 성공 시 이벤트 핸들러
* error : 요청 실패 시 이벤트 핸들러
* complete : 요청 완료 시 이벤트 핸들러
* data : 요청 후 Return 값
* dataType : 요청 후 Return 값의 Data type(xml, html, script, json, jsonp, text)
* async : 요청 시 동기 유무(True/False)
* cache : 페이지 캐시
* beforeSend : 요청 전 이벤트 핸들러
* global : 전역함수 활성 여부 (True/False)  

[1](http://www.nextree.co.kr/p4771/)  
	
# 9. 웹앱

 브라우저를 이용한 HTML, CSS, 자바스크립트를 사용해 만들어진 어플리케이션으로 인터넷 서비스도 이에 포함된다. 
 [1](http://d2.naver.com/helloworld/179084)  
 
 
# 10. aws (ec2 / elastic search / dynamodb/lambda)
## 10.1. EC2 : EC2(Elastic Compute Cloud)는 AWS 클라우드에서 확장식 컴퓨팅을 제공한다. 
[1](http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/concepts.html)  

## 10.2.) Elastic Search : 아파치 루씬을 기반으로 개발된 오픈소스 분산검색엔진
[1](http://d2.naver.com/helloworld/273788)  
[2](http://opennote46.tistory.com/143)  
[3](http://elasticsearch.tistory.com/entry/elasticsearch%EB%9E%80)  
[루씬](http://killsia.tistory.com/443)  

## 10.3. DynamoDB
[1](https://yangbongsoo.gitbooks.io/study/content/dynamodb2.html)  
[2](https://www.slideshare.net/awskr/dynamodb-42890664+&cd=5&hl=ko&ct=clnk&gl=kr)  
[3](http://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/Introduction.html)  

## 10.4. Lambda
[1](http://gun0912.tistory.com/59)  
[2](http://gun0912.tistory.com/60)  
[3](https://aws.amazon.com/ko/blogs/korea/category/aws-lambda/)  
[4](https://www.slideshare.net/awskorea/aws-lambda-100-sangpil-kim)  

# 11. python / flask / sphinx

## 11.1. Python
[1](https://wikidocs.net/6)  

## 11.2. Flask
[1](https://spoqa.github.io/2012/01/16/wsgi-and-flask.html)  
[2](https://code.tutsplus.com/ko/tutorials/an-introduction-to-pythons-flask-framework--net-28822)  

## 11.3. Sphinx
[1](http://sacstory.tistory.com/entry/Debian-%EA%B2%80%EC%83%89-%EC%97%94%EC%A7%84-Sphinx-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0)  
[2](http://crystalcube.co.kr/165)  
[3](http://wiki.pchero21.com/wiki/Sphinx)  
	
# 12. nginx / apache

## 12.1. Nginx
[1](https://opentutorials.org/module/384/3462)  
[2](http://d2.naver.com/helloworld/192785)  
[3](https://openwiki.kr/tech/nginx)  
[4](http://www.haruair.com/blog/1900)  

## 12.2. Apache
[1](https://wiki.archlinux.org/index.php/Apache_HTTP_Server_(%ED%95%9C%EA%B5%AD%EC%96%B4)  
[2](http://cs.sch.ac.kr/lecture/Embedd/06-CompSys-8-Apache.pdf)  

# 13. mysql / mariadb
## 13.1. Mysql
[1](https://wiki.gentoo.org/wiki/MySQL/Startup_Guide/ko)  

## 13.2. MariaDB
[1](https://mariadb.com/kb/ko/mariadb/)  

# 14. rabbitmq / redis

## 14.1. RabbitMQ
[1](http://blog.saltfactory.net/install-rabbitmq/)  
[2](http://bcho.tistory.com/786)  
[3](http://abh0518.net/tok/?p=384)  
[4](https://github.com/gjchoi/gjchoi.github.io/blob/master/_posts/2016-02-27-rabbit-mq-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0.md)  
[5](http://hamait.tistory.com/401)  
[6](http://blog.hkwon.me/rabbitmq-php-node-jsreul-hwalyonghae-gcm-push-ceorihagi/)  

## 14.2. Redis
[1](http://tech.kakao.com/2016/03/11/redis-scan/)  
[2](http://bcho.tistory.com/654)  
[3](http://kerocat.tistory.com/1)  
[4](http://d2.naver.com/helloworld/614607)  
	
	
# 15. json query

	
# 16. monitoring / alert

## 16.1. Monitoring / Alert
[1](http://blurblah.net/1474)  
[2](http://mysqldbadmtech.blogspot.kr/2016/12/pmm-170-mysql-alert.html)  
[3](http://tech.whatap.io/2017/04/21/twitter_monitoring_and_alert-system/)  
[4](https://geunhokhim.wordpress.com/2017/01/02/grafana-influxdb-telegraf-monitoring-server-alerting-automation/)  
[5](http://tech.kakao.com/2016/08/25/kemi/)  
[6](https://engineering.linecorp.com/ko/blog/detail/147)  
[7](https://blog.outsider.ne.kr/1254)  
	

# 17. 최근 관심 분야

함수형 프로그래밍에 관심이 있다. 함수형 프로그래밍이 객체지향형 프로그래밍을 대체할 것이라는 말을 들어서 진짜 그게 가능할까하고 훑어봤는데, 그 동안 생각하지 못했던 요소들이 많아서 사고력을 키우는 차원에서 관심을 가지고 학습하려고 합니다.

예를 들어 러스트라는 함수형 프로그래밍언어는 기본 변수 타입이 상수이고 변수를 사용하기 위해서는 별도로 지정해야한다고 해서 설계한 의도가 무엇일까 생각했던 것이 생각난다.

아마도 명확한 코드를 지향해서 그런 것이라 판단했다.


# 18. 보고 있는 책(공부하고 있는 분야)


***
# 19. 객체지향

* 데이터를 객체로 취급하여 객체 간의 상호작용을 통해 프로그램이 동작하게 하는 설계 기법
* 코드 재사용성이 높다.
* 코드의 변경이 쉽다.
 *코드 분석이 쉽다.
 *객체지향 원칙을 사용하여(캡슐화, 상속, 다형성) 개발속도가 빨라진다.

# 20. Object

객체는 객체지향프로그래밍에서 데이터와 그 데이터에 관련되는 동작, 모두가 포함되는 개념
	
# 21. Overloading과 Overriding

* Overloading 같은 이름의 메소드를 여러 개 정의된 메소드의 매개변수는 타입이나 개수가 다름 return type과 접근 제어자는 영향을 주지 않음
* Overriding 관련 개념 : 상속 상위 클래스의 메소드를 하위 클래스에서 재정의
	
# 22. Call by Reference, Call by Value

* Call by Reference - 매개 변수의 원래 주소에 값을 저장하는 방식. 클래스 객체를 인수로 전달한 경우
* Call by Value - 인수로 기본 데이터형을 사용. 주어진 값을 복사하여 처리하는 방식. 메서드 내의 처리 결과는 메서드 밖의 변수에 영향을 미치지 않는다.

# 23. Static

* 클래스가 로딩될 때, 메모리 공간을 할당하는데 처음 설정된 메모리 공간이 변하지 않음을 의미
* 객체를 아무리 많이 만들어도 해당 변수는 하나만 존재(객체와 무관한 키워드)
	
# 24. Index (Database)

인덱스는 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 일컫는다.
인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다.
고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.
인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다.
데이터베이스에서 테이블과 클러스터에 연관되어 독립적인 저장 공간을 보유하고 있는 객체(object)이다.
사용자는 데이터베이스에 저장된 자료를 더욱 빠르게 조회하기 위하여 인덱스를 생성하고 사용한다.
* DB에서 자료를 검색하는 두 가지 방법
  * FTS(Full Table Scan) : 테이블을 처음 부터 끝까지 검색하는 방법
  * Index Scan : 인덱스를 검색하여 해당 자료의 테이블을 액세스 하는 방법.

# 25. 자료구조

	코딩인터뷰 완전 정복

# 26. 알고리즘

	코딩인터뷰 완전 정복
